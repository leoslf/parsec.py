#!/usr/bin/env python
# -*- coding: utf-8 -*-

import collections as C
import collections.abc as CA
import re
import typing as T

_U = T.TypeVar('_U')
_LocInfo = tuple[int, int]

CH = T.TypeVar('CH')
Text = CA.Sequence["CH"]

class ParseError(RuntimeError):
    expected: str
    text: Text
    index: int
    def __init__(self, expected: str, text: Text, index: int) -> None: ...
    @staticmethod
    def loc_info(text: Text, index: int) -> _LocInfo: ...
    def loc(self) -> str: ...
    def __str__(self) -> str: ...

class Value[U](C.namedtuple('Value', 'status index value expected')):
    @staticmethod
    def success(index: int, actual: U) -> Value[U]: ...
    @staticmethod
    def failure(index: int, expected: str) -> Value[U]: ...
    def aggregate[V](
        self: Value[CA.Sequence[V]], other: T.Optional[Value[CA.Sequence[V]]] = ...
    ) -> Value[CA.Sequence[V]]: ...
    def update_index(self, index: T.Optional[int] = None) -> Value[U]: ...
    @staticmethod
    def combinate[V](values: CA.Iterable[Value[V]]) -> Value[tuple[V, ...]]: ...
    def __str__(self) -> str: ...

class Parser[U]:
    def __init__(self, fn: CA.Callable[[Text, int], Value[U]]) -> None: ...
    def __call__(self, text: Text, index: int) -> Value[U]: ...
    def parse(self, text: Text) -> U: ...
    def parse_partial(self, text: Text) -> tuple[U, Text]: ...
    def parse_strict(self, text: Text) -> U: ...
    @T.overload
    def bind[V](self, fn: CA.Callable[[U], Parser[V]]) -> Parser[V]: ...
    @T.overload
    def bind[V](self, fn: CA.Callable[[U, int], Parser[V]]) -> Parser[V]: ...
    def compose[V](self, other: Parser[V]) -> Parser[V]: ...
    @T.overload
    def joint[A](self, a: Parser[A]) -> Parser[tuple[A]]: ...
    @T.overload
    def joint[A, B](self, a: Parser[A], b: Parser[B]) -> Parser[tuple[A, B]]: ...
    @T.overload
    def joint[A, B, C](self, a: Parser[A], b: Parser[B], c: Parser[C]) -> Parser[tuple[A, B, C]]: ...
    @T.overload
    def joint[A, B, C, D](self, a: Parser[A], b: Parser[B], c: Parser[C], d: Parser[D]) -> Parser[tuple[A, B, C, D]]: ...
    @T.overload
    def joint[A, B, C, D, E](self, a: Parser[A], b: Parser[B], c: Parser[C], d: Parser[D], e: Parser[E]) -> Parser[tuple[A, B, C, D, E]]: ...
    @T.overload
    def joint[A, B, C, D, E, F](self, a: Parser[A], b: Parser[B], c: Parser[C], d: Parser[D], e: Parser[E], f: Parser[F]) -> Parser[tuple[A, B, C, D, E, F]]: ...
    @T.overload
    def joint[*Ts](self, *argv: Parser) -> Parser[tuple[*Ts]]: ...
    def choice[V](self, other: Parser[V]) -> Parser[U | V]: ...
    def try_choice[V](self, other: Parser[V]) -> Parser[U | V]: ...
    def skip[V](self, other: Parser[V]) -> Parser[U]: ...
    def ends_with[V](self, other: Parser[V]) -> Parser[U]: ...
    def excepts[V](self, ohter: Parser[V]) -> Parser[U]: ...
    @T.overload
    def parsecmap[V, *Ts](self, fn: CA.Callable[[U, *Ts], V], star: T.Literal[True]) -> Parser[V]: ...
    @T.overload
    def parsecmap[V](self, fn: CA.Callable[[U], V], star: T.Literal[False]) -> Parser[V]: ...
    @T.overload
    def parsecmap[V, *Ts](self, fn: CA.Callable[[*Ts], V], star: bool = False) -> Parser[V]: ...
    @T.overload
    def map[V, *Ts](self: Parser[tuple[U, *Ts]], fn: CA.Callable[[U, *Ts], V], star: T.Literal[True]) -> Parser[V]: ...
    @T.overload
    def map[V](self, fn: CA.Callable[[U], V], star: T.Literal[False]) -> Parser[V]: ...
    @T.overload
    def map[V](self, fn: CA.Callable[[U], V], star: bool = False) -> Parser[V]: ...
    def parsecapp[V, *Ts](
        self: Parser[CA.Callable[[U, *Ts], V]], other: Parser[tuple[*Ts]]
    ) -> Parser[V]: ...
    def apply[V, *Ts](
        self: Parser[CA.Callable[[U, *Ts], V]], other: Parser[tuple[*Ts]]
    ) -> Parser[V]: ...
    def result[V](self, res: V) -> Parser[V]: ...
    def mark(self) -> Parser[tuple[_LocInfo, U, _LocInfo]]: ...
    def desc(self, description: str) -> Parser[U]: ...
    def __or__[V](self, other: Parser[V]) -> Parser[U | V]: ...
    def __xor__[V](self, other: Parser[V]) -> Parser[U | V]: ...
    def __add__[V](self, other: Parser[V]) -> Parser[tuple[U, V]]: ...
    def __rshift__[V](self, other: Parser[V]) -> Parser[V]: ...
    def __gt__[V](self, other: Parser[V]) -> Parser[V]: ...
    def __irshift__[V, *Ts](self: Parser[tuple[U, *Ts]], other: CA.Callable[[U, *Ts], Parser[V]]) -> Parser[V]: ... # type: ignore[misc]
    def __ge__[V](self, other: Parser[V]) -> Parser[V]: ...
    def __lshift__[V](self, other: Parser[V]) -> Parser[U]: ...
    def __lt__[V](self, other: Parser[V]) -> Parser[U]: ...
    def __truediv__[V](self, other: Parser[V]) -> Parser[U]: ...

def parse[V](p: Parser[V], text: Text, index: int) -> V: ...
@T.overload
def bind[U, V](p: Parser[U], fn: CA.Callable[[U], Parser[V]]) -> Parser[V]: ...
@T.overload
def bind[U, V](p: Parser[U], fn: CA.Callable[[U, int], Parser[V]]) -> Parser[V]: ...
def compose[V](pa: Parser, pb: Parser[V]) -> Parser[V]: ...
@T.overload
def joint[A](a: Parser[A]) -> Parser[tuple[A]]: ...
@T.overload
def joint[A, B](a: Parser[A], b: Parser[B]) -> Parser[tuple[A, B]]: ...
@T.overload
def joint[A, B, C](a: Parser[A], b: Parser[B], c: Parser[C]) -> Parser[tuple[A, B, C]]: ...
@T.overload
def joint[A, B, C, D](a: Parser[A], b: Parser[B], c: Parser[C], d: Parser[D]) -> Parser[tuple[A, B, C, D]]: ...
@T.overload
def joint[A, B, C, D, E](a: Parser[A], b: Parser[B], c: Parser[C], d: Parser[D], e: Parser[E]) -> Parser[tuple[A, B, C, D, E]]: ...
@T.overload
def joint[A, B, C, D, E, F](a: Parser[A], b: Parser[B], c: Parser[C], d: Parser[D], e: Parser[E], f: Parser[F]) -> Parser[tuple[A, B, C, D, E, F]]: ...
def choice[U, V](pa: Parser[U], pb: Parser[V]) -> Parser[U | V]: ...
def try_choice[A, B](pa: Parser[A], pb: Parser[B]) -> Parser[A | B]: ...
def try_choices[U](*parsers: Parser[U]) -> Parser[U]: ...
def try_choices_longest[U](*parsers: Parser[U]) -> Parser[U]: ...
def skip[A](pa: Parser[A], pb: Parser) -> Parser[A]: ...
def ends_with[A](pa: Parser[A], pb: Parser) -> Parser[A]: ...
def excepts[A](pa: Parser[A], pb: Parser) -> Parser[A]: ...
def parsecmap[U, V](p: Parser[U], fn: CA.Callable[[U], V]) -> Parser[V]: ...
def parsecapp[U, V](p: Parser[CA.Callable[[U], V]], other: Parser[U]) -> Parser[V]: ...
def result[U](p: Parser, res: U) -> Parser[U]: ...
def mark[U](p: Parser[U]) -> Parser[tuple[_LocInfo, U, _LocInfo]]: ...
def desc[U](p: Parser[U], description: str) -> Parser[U]: ...
@T.overload
def generate[U, V](
    fn: str,
) -> CA.Callable[
    [CA.Callable[[], CA.Generator[Parser[U], U, Parser[V] | V]]], Parser[V]
]: ...
@T.overload
def generate[U, V](
    fn: CA.Callable[[], CA.Generator[Parser[U], U, Parser[V] | V]]
) -> Parser[V]: ...
def times[U](
    p: Parser[U], mint: int, maxt: T.Optional[float] = ...
) -> Parser[list[U]]: ...
def count[U](p: Parser[U], n: int) -> Parser[list[U]]: ...
@T.overload
def optional[U](
    p: Parser[U], default_value: None = None
) -> Parser[U | None]: ...
@T.overload
def optional[U, V](
    p: Parser[U], default_value: V
) -> Parser[U | V]: ...
def many[U](p: Parser[U]) -> Parser[list[U]]: ...
def many1[U](p: Parser[U]) -> Parser[list[U]]: ...
def separated[U](
    p: Parser[U],
    sep: Parser,
    mint: int,
    maxt: T.Optional[int] = ...,
    end: T.Optional[bool] = ...,
) -> Parser[list[U]]: ...
def sepBy[U](p: Parser[U], sep: Parser) -> Parser[list[U]]: ...
def sepBy1[U](p: Parser[U], sep: Parser) -> Parser[list[U]]: ...
def endBy[U](p: Parser[U], sep: Parser) -> Parser[list[U]]: ...
def endBy1[U](p: Parser[U], sep: Parser) -> Parser[list[U]]: ...
def sepEndBy[U](p: Parser[U], sep: Parser) -> Parser[list[U]]: ...
def sepEndBy1[U](p: Parser[U], sep: Parser) -> Parser[list[U]]: ...
def satisfy[U](predicate: CA.Callable[[U], bool]) -> Parser[U]: ...
def any() -> Parser: ...
def one_of[U](s: CA.Container[U]) -> Parser[U]: ...
def none_of[U](s: CA.Container[U]) -> Parser[U]: ...
def space() -> Parser[str]: ...
def spaces() -> Parser[list[str]]: ...
def letter() -> Parser[str]: ...
def digit() -> Parser[str]: ...
def eof() -> Parser[None]: ...
def string[S: CA.Sequence](s: S) -> Parser[S]: ...
def regex(exp: str | re.Pattern, flags: re.RegexFlag = ...) -> Parser[str]: ...
def newline() -> Parser[str]: ...
def crlf() -> Parser[str]: ...
def end_of_line() -> Parser[str]: ...
def success_with[U](value: U, advance: bool = False) -> Parser[U]: ...
def fail_with(message: str) -> Parser: ...
def exclude[U](p: Parser[U], exclude: Parser) -> Parser[U]: ...
def lookahead[U](p: Parser[U]) -> Parser[U]: ...
def unit[U](p: Parser[U]) -> Parser[U]: ...
def between[U](open: Parser, close: Parser, parser: Parser[U]) -> Parser[U]: ...
def validate[U](predicate: CA.Callable[[U], bool]) -> Parser[U]: ...

sign: Parser[CA.Callable[[_U], _U]]

def number(base: int, digit: Parser[str]) -> Parser[int]: ...

binary_digit: Parser[str]
binary_number: Parser[int]
binary: Parser[int]

octal_digit: Parser[str]
octal_number: Parser[int]
octal: Parser[int]

hexadecimal_digit: Parser[str]
hexadecimal_number: Parser[int]
hexadecimal: Parser[int]

decimal_number: Parser[int]
decimal: Parser[int]

zero_number: Parser[int]
natural: Parser[int]
integer: Parser[int]
